#!/usr/bin/python3

import datetime
import json
import os
import re
import readline
import shutil
import subprocess
import sys
import syslog

from datetime import timedelta
from os.path import join as pjoin
from os.path import exists,isdir
from struct import pack,unpack
from syslog import syslog as log
from time import time

import doomrl

# DoomRL loads score.wad and player.wad on startup, holds them in memory for its
# entire run, and writes them out on exit.
# Score.wad is a gzipped XML file containing the scores. It starts with a CRC,
# and if this CRC is incorrect, will attempt to restore score.wad from backup
# or, failing that, erase it and start over. So merging score.wad is a no-go
# unless we can reverse engineer the CRC. It looks the right size to be md5.

class TTYRec(object):
  """A custom TTYRec recorder for DoomRL.

  This class needs a bit of explanation. See, DoomRL's tty handling code is kind
  of buggy and constantly spams no-op commands even when nothing is happening.
  This has two unfortunate consequences: the ttyrec files are huge, and ttyplay
  can't skip large sections of inactivity (because everything looks like
  activity all the time).

  This class does two things. First, it automatically drops frames which
  consist only of these no-op commands (in a kind of hackish way, but it works).
  Second, it adjusts the frame timing to trim out large periods of inactivity
  (which may range from seconds to -- if a game was resumed from save after a
  long period of inactivity -- weeks or more).

  It completely replaces the use of ttyrec; this class simultaneously filters
  the output of DoomRL and writes the ttyrec file.
  """
  def __init__(self, pipe, path, stdout=1):
    self.last_sgr = None
    self.last_pos = None
    self.last_s = int(time())
    self.delta = 0
    self.doomrl = pipe
    self.stdout = stdout

    # If the file exists, read it to determine our current timestamp
    if exists(path):
      self.set_time_from(path)

    # Open the file for append
    self.fd = open(path, "ab")

    import tty
    tty.setraw(stdout)
    tty.setcbreak(stdout)

  def __enter__(self):
    return self

  def __exit__(self, type, value, stack):
    self.fd.close()

  def set_time_from(self, path):
    with open(path, "rb") as fd:
      while True:
        header = fd.read(12)
        if not header:
          break
        (s, us, sz) = unpack("III", header)
        fd.read(sz)
        self.last_s = s

  def strip_pos(self, match):
    if match.group(0) == self.last_pos:
      return b''
    self.last_pos = match.group(0)
    return match.group(0)

  def strip_sgr(self, match):
    if match.group(0) == self.last_sgr:
      return b''
    self.last_sgr = match.group(0)
    return match.group(0)

  def write(self, s, us, sz, data):
    # strip out garbage commands
    trimmed = re.sub(b'\x1B\\[\\d+;\\d+H', self.strip_pos, data)
    trimmed = re.sub(b'\x1B\\[[\\d;]+m', self.strip_sgr, trimmed)
    trimmed = re.sub(b'\x1B\\[\\?7l', b'', trimmed)
    if trimmed:
      # If the frame survived, write it out.
      os.write(self.stdout, data)
      #os.fsync(self.stdout)
      # Correct the timestamp first, if needed.
      if (s - self.delta) - self.last_s > 2:
        self.delta = s - self.last_s - 1
      s -= self.delta
      self.last_s = s
      self.fd.write(pack("III", s, us, sz) + data)
      self.fd.flush()

  def wait(self):
    # Now we read from the pipe and process the output until it's closed,
    # stripping out garbage frames and writing the rest to disk.
    while True:
      data = os.read(self.doomrl, 8192)
      # Split timestamp into seconds and microseconds
      ts = time()
      s = int(ts)
      us = int(ts % 1 * 1e6)
      if not data:
        break
      self.write(s, us, len(data), data)

commands = {}
class CommandRegistration(type):
  def __new__(cls, clsname, bases, attrs):
    global commands
    newclass = super().__new__(cls, clsname, bases, attrs)
    name = clsname.replace('Command', '').lower()
    if name:
      commands[name] = newclass()
    return newclass

class Command(object, metaclass=CommandRegistration):
  nargs = 0
  def run(self, *args):
    return 'Not implemented yet.'

class RegisterCommand(Command):
  """register <name> <pass> -- create a new account

  Attempts to create (and log in to) a new user account. You can spectate and
  view the high score list as a guest, but in order to actually play you need to
  register.

  The username will be used as both your login username and your DoomRL username
  (and thus will appear on the high score list) and has certain restrictions as
  a result: 24 character maximum, alphanumeric ASCII only. The password can
  contain anything, including whitespace."""

  nargs = 2

  def install(self, home, name, password):
    """Install a personal copy of DoomRL to the given path."""
    # The player gets symlinks to the doomrl binary and wad files. They get
    # their own personal backup, mortem, screenshot, and recording directories,
    # and their own personal config files (so that they can be edited).
    for file in ['core.wad', 'doomrl', 'doomrl.wad']:
      os.symlink(os.path.join('../../doomrl', file), doomrl.home(file, user=name))
    for file in ['colours.lua', 'controls.lua', 'user.lua']:
      shutil.copy(doomrl.path('config', file), doomrl.home(file, user=name))
    for file in os.listdir(doomrl.path('config')):
      if not exists(doomrl.home(file, user=name)):
        os.symlink(os.path.join('../../config', file), doomrl.home(file, user=name))
    for dir in ['backup', 'mortem', 'screenshot', 'saves', 'archive']:
      os.mkdir(pjoin(home, dir))
    with open(pjoin(home, 'passwd'), 'w') as passwd:
      passwd.write(password)
    # Create empty scores file
    open(pjoin(home, 'archive', 'scores'), 'w').close()


  def run(self, name, password):
    # Check name validity
    if not doomrl.name_valid(name):
      return 'Invalid name.'

    # Check that password was specified
    if not password:
      return 'No password specified.'

    # Try to create user directory and die if we can't
    home = doomrl.home(user=name)
    try:
      os.mkdir(home)
    except OSError as e:
      return 'That name is unavailable.'

    # Fill in user directory
    log('Creating a new account: %s' % name)
    print('Creating user account.')
    try:
      self.install(home, name, password)
    except Exception as e:
      log('Error creating account %s: %s' % (name, e))
      print('Error creating user directory.')
      print('Report this to the server administrator.')
      if doomrl.debug():
        raise e
      try:
        shutil.rmtree(home)
      except OSError as e:
        log('Error cleaning up account %s: %s' % (name, e))
        print('Error cleaning up the half-created user directory! This username is unavailable until the admin fixes things.')
      finally:
        doomrl.login()
        return 'Unable to create user.'

    # Login
    return commands['login'].run(name, password)

class ConfigCommand(Command):
  """config <file> [reset] -- edit or reset configuration files

  As "config <file>", lets you edit one of your DoomRL configuration files.
  As "config <file> reset", lets you reset a file to defaults.
  As "config all reset", resets all files to defaults.

  Available files are:

    controls -- keyboard controls
    colours  -- game display colours
    user     -- user settings and general configuration

  Note that DoomRL has options not listed in any of these files; these options
  are overriden by the server and adding them yourself will have no effect.
  """

  nargs = 2

  def run(self, file, reset):
    if not doomrl.user():
      return 'You must be logged in.'

    if reset and reset != 'reset':
      return 'Invalid second argument. See "help config".'

    files = frozenset(['controls', 'colours', 'user'])

    if reset and file == "all":
      print("Restoring default configuration files.")
      for file in os.listdir(doomrl.path('config')):
        shutil.copy(doomrl.path('config', file), doomrl.home(file))
      with open(doomrl.home('config.lua'), 'a') as config:
        config.write('AlwaysName = "%s"\n' % doomrl.user())
      return

    if not file:
      print('Try "config <controls|colours|user>" or "help config".')
      return

    if file not in files:
      return 'Unknown file -- see "help config".'

    if reset:
      print('Restoring %s.lua to defaults.')
      shutil.copy(doomrl.path('config', '%s.lua' % file), doomrl.home())
      return

    # Use Nano in secure mode to edit the file.
    subprocess.call(
      ['nano', '-R', doomrl.home('%s.lua' % file)])

class LoginCommand(Command):
  """login <name> <pass> -- log in to an existing account.

  This is necessary in order to actually play games. To create a new account,
  use "register"."""

  nargs = 2

  def run(self, name, password):
    if doomrl.user():
      return 'You are already logged in!'

    if not name or not password:
      return 'You must specify both a username and a password.'

    # Check password
    try:
      with open(doomrl.home('passwd', user=name)) as f:
        passwd = f.read()
      if passwd == password:
        log('%s successfully logged in.' % name)
        doomrl.login(name)
        return
    except IOError as e:
      pass

    log('Failed login attempt as %s' % name)
    doomrl.login()
    return 'Login failed.'

class HelpCommand(Command):
  """help [command] -- built in help for the DoomRL server.

  With no arguments, list all commands. With a command specified, shows detailed
  help for that command."""

  nargs = 1

  def run(self, cmd):
    from inspect import getdoc

    if not cmd:
      for cmd in commands:
        print(getdoc(commands[cmd]).split('\n')[0])
      return

    if not cmd in commands:
      print('No such command. Try "help" for a list of all commands.')
    else:
      print(getdoc(commands[cmd]))

class PlayCommand(Command):
  """play <name> -- start or continue a game of DoomRL.

  Without arguments, list your saved games. With a name, start or resume a game
  with that name.

  The game will automatically be recorded and made available for spectating.

  If you save and quit, the savegame will be automatically archived under the
  name you chose. You can resume it later by providing the same name, or start
  a new game in parallel by providing a different one. This allows you to (for
  example) have a long running Angel of 666 game in one save, while still taking
  breaks for shorter standard games.
  """

  nargs = 1

  def setup(self, name):
    # If the player has a game in progress, restore their ttyrec and save.
    if exists(doomrl.home('saves', name + '.ttyrec')):
      os.rename(doomrl.home('saves', name + '.ttyrec'), self.recfile)
      print('Recording of current game restored.')
    if exists(doomrl.home('saves', name)):
      os.rename(doomrl.home('saves', name), doomrl.home('save'))

    # Get their pre-game high scores so we can check for new ones afterwards.
    scores_before = doomrl.raw_scores()
    try:
      mortem_before = doomrl.raw_mortems()[-1]
    except IndexError:
      mortem_before = None

    return (scores_before,mortem_before)

  def run_doomrl(self):
    if exists(doomrl.path('ttysound', 'libSDL_mixer-1.2.so.0')):
      cmd = ['./doomrl']
      env = {
        "LD_LIBRARY_PATH": doomrl.path('ttysound'),
        "SDL_AUDIODRIVER": 'disk',
        'SDL_DISKAUDIOFILE': '/dev/null',
        'TERM': os.getenv('TERM'),
      }
    else:
      cmd = ['./doomrl', '-nosound']
      env = { 'TERM': os.getenv('TERM') }

    (rpipe,wpipe) = os.pipe()
    child = subprocess.Popen(cmd, stdout=wpipe, env=env, cwd=doomrl.home())
    os.close(wpipe)

    with TTYRec(rpipe, self.recfile) as rec:
      # This will return when DoomRL closes the fd.
      rec.wait()
    child.wait()

  def run(self, name):
    if not doomrl.user():
      return 'You must log in first.'

    if not name:
      # List games in progress
      saves = os.listdir(doomrl.home('saves'))
      if not saves:
        print('You have no games in progress.')
      else:
        print('Games in progress:')
        for save in [s for s in saves if not s.endswith('.ttyrec')]:
          print('\t', save)
        print('Type "play <name>" to resume one.')
      return

    # We can be a bit looser about names here, but for simplicity's sake we
    # just reuse the name validation code we use for player names.
    if not doomrl.name_valid(name):
      return 'Invalid save name.'

    # Check that they aren't already playing *right now*.
    self.recfile = doomrl.home('ttyrec')
    if exists(self.recfile):
      return 'You are already playing in another window! Quit that game first.'

    (scores,mortem) = self.setup(name)
    try:
      self.run_doomrl()
    except Exception as e:
      # If something went wrong while playing DoomRL, the terminal is probably
      # completely hosed and there may still be processes running in the
      # background. Nothing to do here but die and hope the SIGHUP gets them.
      subprocess.call(['reset'])
      if doomrl.debug():
        raise e
      print('Fatal error running DoomRL:', e)
      sys.exit(1)
    finally:
      self.shutdown(name, scores, mortem)

  def shutdown(self, name, scores_before, mortem_before):
    # If the game is still in progress, save the ttyrec file.
    if exists(doomrl.home('save')):
      os.rename(self.recfile, doomrl.home('saves', name + '.ttyrec'))
      os.rename(doomrl.home('save'), doomrl.home('saves', name))
    else:
      # Otherwise, there *should* be a new high score entry and a new mortem.
      # Unless they simply didn't start a game in the first place.
      try:
        mortem = doomrl.raw_mortems()[-1]
      except IndexError:
        mortem = None

      if mortem == mortem_before:
        # No new postmortem created and no save file means no game played.
        os.remove(self.recfile)
        return

      scores_after = doomrl.raw_scores()
      n = len(scores_after)

      # Save the ttyrec and mortem files to the player archive directory.
      os.rename(self.recfile,
                doomrl.home('archive', '%d.ttyrec' % n))
      shutil.copy(doomrl.home('mortem', mortem),
                  doomrl.home('archive', '%d.mortem' % n))

      # Write the new score entry to the player's scores file.
      mortem = doomrl.parse_mortem(n)
      for (i,score) in enumerate(scores_after):
        if i >= len(scores_before) or scores_before[i] != score:
          with open(doomrl.home('archive', 'scores'), "a") as fd:
            score['n'] = n
            score['time'] = mortem['time']
            fd.write(json.dumps(score) + '\n')
            break

      doomrl.build_website('www')


class DeleteCommand(Command):
  """delete <game> -- delete a game in progress.

  Delete the save file and recording associated with an in-progress game. Unlike
  loading the game and then committing suicide, this doesn't result in a high
  score entry -- the game is just gone.
  """

  nargs = 1

  def run(self, name):
    if not doomrl.user():
      return 'You must log in first.'

    saves = os.listdir(doomrl.home('saves'))
    if not name:
      # List games in progress
      if not saves:
        print('You have no games in progress.')
      else:
        print('Games in progress:')
        for save in [s for s in saves if not s.endswith('.ttyrec')]:
          print('\t', save)
        print('Type "delete <name>" to delete one.')
      return

    if not name in saves:
      return 'No such game.'

    os.remove(doomrl.home('saves', name))
    os.remove(doomrl.home('saves', name + '.ttyrec'))
    print('In-progress game ' + name + ' deleted.')

class WatchCommand(Command):
  """watch <player> -- watch an in-progress game of DoomRL.

  With no arguments, lists all currently active games. With the name of a
  player, spectates that player's game.

  The replay has an initial 'catch-up' phase where it replays the game so far
  at 64x normal speed. During this period the normal replay controls (see
  "help replay") will work. At any point you can exit spectator mode with ctrl-C.

  If the person you are spectating exits, the screen will go black and won't
  automatically return to the prompt -- this is a limitation of the underlying
  software used for replays. Once this happens, press ctrl-C to exit.
  """

  nargs = 1

  def run(self, player):
    if not player:
      # list active games
      print('   TIME PLAYER')
      for player in doomrl.all_users():
        if exists(doomrl.home('ttyrec', user=player)):
          time = subprocess.check_output(['ttytime', 'ttyrec'], cwd=doomrl.home(user=player)).split()[0]
          print("%7s %s" % (str(timedelta(seconds=int(time))), player))
      return

    if not exists(doomrl.home('ttyrec', user=player)):
      return 'No game in progress under that name.'

    try:
      # First we 'catch up' by playing the replay so far at max speed.
      subprocess.call(
        ['ttyplay', '-n', 'ttyrec'],
        cwd=doomrl.home(user=player))
      # Then we peek at what remains.
      subprocess.call(
        ['ttyplay', '-p', 'ttyrec'],
        cwd=doomrl.home(user=player))
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class ScoresCommand(Command):
  """scores [player] -- show high score list

  With no arguments, show the entire scoreboard. With a given player, show only
  scores for that player. Use the arrow keys or pageup/down to scroll, and q to
  quit.

  Note that due to restrictions on how DoomRL stores the high score list, the
  in-game high scores will always only show your own."""

  nargs = 1

  def run(self, player):
    if not player:
      games = []
      for player in doomrl.all_users():
        games += doomrl.games(player)
    else:
      games = doomrl.games(player)

    games.sort(reverse=True, key=lambda s: int(s['score']))
    doomrl.show_scores(games)

class ReplayCommand(Command):
  """replay <player> <number> -- replay a recorded game

  With no arguments, lists all players with recorded games. With a player name,
  lists the recorded games for that player. With a name and a replay number,
  replays the given name. The replay number can be found out from the list of
  that player's replays.

  You can also use "latest" to view the latest replay for that player.

  Replay controls:
    f or +: go faster
    s or -: go slower
    1: reset speed
    ctrl-c: exit replay
  """

  nargs = 2

  def replays(self, player):
    return [game for game in doomrl.games(player)
            if exists(doomrl.home('archive', '%d.ttyrec' % game['n'], user=player))]

  def list_players(self):
    """List all players with recordings, and how many."""
    print('  NUM | PLAYER')
    for player in doomrl.all_users():
      replays = len(self.replays(player))
      if replays > 0:
        print(' %4d | %s' % (replays, player))

  def run(self, player, id):
    if not player:
      return self.list_players()
    elif not doomrl.user_exists(player):
      return 'No such player: %s' % player
    elif not id:
      return doomrl.show_scores(self.replays(player), time='ttytime')

    # Replay the named recording.
    replays = self.replays(player)
    if id == "latest":
      id = replays[-1]['n']
    else:
      try:
        id = int(id)
      except:
        return 'Invalid replay ID.'

    replay = doomrl.home('archive', '%d.ttyrec' % id, user=player)
    if not exists(replay):
      return 'No replay with that ID found for that player.'

    try:
      subprocess.call(
        ['ttyplay', replay],
        cwd=doomrl.home('archive', user=player))
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class MortemCommand(Command):
  """mortem <player> <number> -- view a postmortem

  With no arguments, lists all players with postmortems. With a player name,
  lists the available postmortems. With a number or date, view that postmortem.

  You can also use "latest" to view the latest postmortem for that player.

  The viewer used is less(1). Use pageup/down or the arrow keys to scroll, q to
  quit. You can press h or H at any time for help.
  """

  nargs = 2

  def mortems(self, player):
    return [game for game in doomrl.games(player)
            if exists(doomrl.home('archive', '%d.mortem' % game['n'], user=player))]

  def list_players(self):
    """List all players with mortems, and how many."""
    print('  NUM | PLAYER')
    for player in doomrl.all_users():
      mortems = len(self.mortems(player))
      if mortems > 0:
        print(' %4d | %s' % (mortems, player))

  def run(self, player, id):
    if not player:
      return self.list_players()
    elif not doomrl.user_exists(player):
      return 'No such player: %s' % player
    elif not id:
      return doomrl.show_scores(self.mortems(player))

    mortems = self.mortems(player)
    if id == "latest":
      id = mortems[-1]['n']
    else:
      try:
        id = int(id)
      except:
        return 'Invalid mortem ID.'

    mortem = doomrl.home('archive', '%d.mortem' % id, user=player)
    if not exists(mortem):
      return 'No mortem with that ID found for that player.'

    try:
      subprocess.call(
        ['less', '-d', '-M', mortem],
        cwd=doomrl.home('archive', user=player),
        env={
          'LESSSECURE': '1',
          'TERM': os.getenv('TERM')
        })
    except KeyboardInterrupt:
      pass

class RebuildCommand(Command):
  """rebuild -- regenerate the score and mortem index. Admins only.

  This command rescans the archived postmortems and ttyrecs of each player to
  correct errors in the master score index. These errors are usually the result
  of bugs in an earlier version of doomrl-server.

  At the moment it only corrects errors in the 'time' and 'ttytime' fields.
  """

  def run(self):
    if not doomrl.debug():
      print('Server administrators only!')
      return

    for player in doomrl.all_users():
      games = doomrl.games(player)  # scores from the player's score index
      for (i,game) in enumerate(games):
        if game.get('time', 0) == 0:
          mortem = doomrl.parse_mortem(game['n'], player)
          game['time'] = mortem['time']
        if game.get('ttytime', None) is None:
          if exists(doomrl.home('archive', '%d.ttyrec' % game['n'], user=player)):
            ttytime = subprocess.check_output(
              ['ttytime', 'archive/%d.ttyrec' % game['n']],
              cwd=doomrl.home(user=player)).split()[0]
            game['ttytime'] = int(ttytime)
          else:
            game['ttytime'] = 0  # no replay available
      with open(doomrl.home('archive', 'scores', user=player), "w") as fd:
        for game in games:
          fd.write(json.dumps(game) + '\n')
      print('%s: rebuilt %d records' % (player, len(games)))

    doomrl.build_website('www')


def sighup(sig, frame):
  """Signal handler for SIGHUP, which is raised when the user disconnects suddenly."""
  # TODO: clean up half-created user directories.

  if doomrl.user():
    # If we got interrupted while the player was actually in DoomRL, there's a
    # ttyrec file. We could try recovering it, but DoomRL's crash recovery is
    # so unreliable that we probably can't match it up to a save file or
    # scoreline, so we might as well just delete it.
    try:
      os.remove(doomrl.home('ttyrec'))
    except:
      pass


def argsplit(string, max=2):
  args = string.split(maxsplit=max-1)
  while len(args) < max:
    args.append('')
  return args

def main():
  from signal import signal,SIGHUP
  signal(SIGHUP, sighup)

  syslog.openlog('doomrl-server', facility=syslog.LOG_DAEMON)

  if exists(doomrl.path('motd')):
    print(open(doomrl.path('motd')).read())

  (cols, rows) = shutil.get_terminal_size()
  if int(rows) < 25 or int(cols) < 80:
    print("Warning: your terminal size (%sx%s) is smaller than the 80x25"
          " needed by DoomRL. The 'play', 'replay', and 'watch' commands"
          " may not work correctly." % (cols, rows))

  while True:
    try:
      if exists(doomrl.path('maintenance')):
        print(open(doomrl.path('maintenance')).read())
        sys.exit(0)
      [cmd, args] = argsplit(input('\n%s> ' % (doomrl.user() or 'guest')).strip())
      if cmd in commands:
        result = commands[cmd].run(*argsplit(args, max=commands[cmd].nargs))
        if result:
          print('Error: %s' % result)
      elif cmd == 'quit':
        break
      elif not cmd:
        pass
      else:
        print('Error: Unrecognized command. Try "help".')
    except EOFError as e:
      break
    except KeyboardInterrupt:
      pass
    except Exception as e:
      log('Unhandled exception in mainloop: %s' % str(e))
      print('Error in mainloop: %s' % str(e))
      if doomrl.debug():
        raise e

  if doomrl.user():
    log('User %s logged out.' % doomrl.user())
  print('Goodbye!')

if __name__ == '__main__':
  main()
