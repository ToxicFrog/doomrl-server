#!/usr/bin/python3

import os
import readline
import shutil
import subprocess

from os.path import join as pjoin

# DoomRL loads score.wad and player.wad on startup, holds them in memory for its
# entire run, and writes them out on exit.
# Score.wad is a gzipped XML file containing the scores. It starts with a CRC,
# and if this CRC is incorrect, will attempt to restore score.wad from backup
# or, failing that, erase it and start over. So merging score.wad is a no-go
# unless we can reverse engineer the CRC. It looks the right size to be md5.

class DoomRL(object):
  # Set up paths
  root = os.getenv('DOOMRL_SERVER') or os.getenv('HOME')
  config = pjoin(root, 'config')
  doomrl = pjoin(root, 'doomrl')
  players = pjoin(root, 'players')
  www = pjoin(root, 'www')
  # Global state
  user = 'guest'
  home = None

commands = {}
class CommandRegistration(type):
  def __new__(cls, clsname, bases, attrs):
    global commands
    newclass = super().__new__(cls, clsname, bases, attrs)
    name = clsname.replace('Command', '').lower()
    if name:
      commands[name] = newclass()
    return newclass

class Command(object, metaclass=CommandRegistration):
  nargs = 0
  def run(self, *args):
    return 'Not implemented yet.'

class RegisterCommand(Command):
  """register <name> <pass> -- create a new account

  Attempts to create (and log in to) a new user account. You can spectate and
  view the high score list as a guest, but in order to actually play you need to
  register.

  The username will be used as both your login username and your DoomRL username
  (and thus will appear on the high score list) and has certain restrictions as
  a result: 24 character maximum, alphanumeric ASCII only. The password can
  contain anything, including whitespace."""

  nargs = 2

  def name_valid(self, name):
    return 0 < len(name) <= 24 and bytes(name, encoding='utf8').isalnum()

  def install(self, home, name, password):
    """Install a personal copy of DoomRL to the given path."""
    # The player needs their own personal player.wad, score.wad, and backup,
    # mortem and screenshot directories.
    # They also need a personalized name.lua that is generated on the fly.
    # They get symlinks to colors.lua, config.lua, core.wad, doomrl, doomrl.wad,
    # and keybindings.lua.
    for file in ['player.wad', 'score.wad']:
      shutil.copy(pjoin(DoomRL.doomrl, file), home)
    for file in ['core.wad', 'doomrl', 'doomrl.wad']:
      os.symlink(pjoin(DoomRL.doomrl, file), pjoin(home, file))
    for file in ['colors.lua', 'config.lua', 'keybindings.lua']:
      os.symlink(pjoin(DoomRL.config, file), pjoin(home, file))
    for dir in ['backup', 'mortem', 'screenshot']:
      os.mkdir(pjoin(home, dir))
    with open(pjoin(home, 'passwd'), 'w') as passwd:
      passwd.write(password)
    with open(pjoin(home, 'user.lua'), 'w') as config:
      config.write('AlwaysName = "%s"\n' % name)


  def run(self, name, password):
    # Check name validity
    if not self.name_valid(name):
      return 'Invalid name.'

    # Check that password was specified
    if not password:
      return 'No password specified.'

    # Try to create user directory and die if we can't
    print('Creating user account.')
    home = pjoin(DoomRL.players, name)
    try:
      os.mkdir(home)
    except OSError as e:
      return 'Unable to create user directory; most likely this name is already in use.'

    # Fill in user directory
    try:
      self.install(home, name, password)
    except Exception as e:
      print('Error creating user directory: %s', e)
      print('Report this to the server administrator.')
      try:
        shutil.rmtree(home)
      except OSError as e:
        print('Error cleaning up the half-created user directory! This usename is unavailable until the admin fixes things.')
      finally:
        return 'Unable to create user.'

    # Login
    return commands['login'].run(name, password)

class LoginCommand(Command):
  """login <name> <pass> -- log in to an existing account.

  This is necessary in order to actually play games. To create a new account,
  use "register"."""

  nargs = 2

  def run(self, name, password):
    if DoomRL.home:
      return 'You are already logged in!'

    if not name or not password:
      return 'You must specify both a username and a password.'

    # Check password
    home = os.path.join(DoomRL.players, name)
    try:
      with open(os.path.join(home, 'passwd')) as f:
        passwd = f.read()
    except IOError as e:
      return 'Login failed.'

    if passwd != password:
      print(passwd, password)
      return 'Login failed.'

    DoomRL.home = home
    DoomRL.name = name

class HelpCommand(Command):
  """help [command] -- built in help for the DoomRL server.

  With no arguments, list all commands. With a command specified, shows detailed
  help for that command."""

  nargs = 1

  def run(self, cmd):
    from inspect import getdoc

    if not cmd:
      for cmd in commands:
        print(getdoc(commands[cmd]).split('\n')[0])
      return

    if not cmd in commands:
      print('No such command. Try "help" for a list of all commands.')
    else:
      print(getdoc(commands[cmd]))

class PlayCommand(Command):
  """play -- play a game of DoomRL.

  The game will automatically be recorded and made available for spectating."""

  def run(self):
    if not DoomRL.home:
      return 'You must log in first.'

    subprocess.call(
      ['ttyrec', '-e', './doomrl', '-a', recfile],
      cwd=)

class WatchCommand(Command):
  """watch <player> -- watch an in-progress game of DoomRL.

  With no arguments, lists all currently active games. With the name of a
  player, spectates that player's game."""

  nargs = 1

class ReplayCommand(Command):
  """replay <player> <time> -- replay a recorded game

  With no arguments, lists all players with recorded games. With a player name,
  lists the recorded games for that player. With a name and a date/time stamp,
  replays that game.

  Replay controls:
    f or +: go faster
    s or -: go slower
    1: reset speed to realtime
    anything else: skip to the next player input (useful for long idle periods)
  """

  nargs = 2

def argsplit(string, max=2):
  args = string.split(maxsplit=max-1)
  while len(args) < max:
    args.append('')
  return args

def main():
  while True:
    try:
      [cmd, args] = argsplit(input('\n%s> ' % DoomRL.user))
      if cmd in commands:
        result = commands[cmd].run(*argsplit(args, max=commands[cmd].nargs))
        if result:
          print('Error: %s' % result)
      elif not cmd:
        pass
      else:
        print('Error: Unrecognized command. Try "help".')
    except EOFError as e:
      print('Goodbye!')
      break

if __name__ == '__main__':
  main()
