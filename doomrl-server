#!/usr/bin/python3

import datetime
import os
import readline
import shutil
import subprocess
import syslog

from os.path import join as pjoin
from os.path import exists,isdir
from syslog import syslog as log

# DoomRL loads score.wad and player.wad on startup, holds them in memory for its
# entire run, and writes them out on exit.
# Score.wad is a gzipped XML file containing the scores. It starts with a CRC,
# and if this CRC is incorrect, will attempt to restore score.wad from backup
# or, failing that, erase it and start over. So merging score.wad is a no-go
# unless we can reverse engineer the CRC. It looks the right size to be md5.

class DoomRL(object):
  # Set up paths
  root = os.getenv('DOOMRL_SERVER') or os.path.dirname(os.path.realpath(__file__))
  config = pjoin(root, 'config')
  doomrl = pjoin(root, 'doomrl')
  games = pjoin(root, 'games')
  players = pjoin(root, 'players')
  www = pjoin(root, 'www')
  # Global state
  user = 'guest'
  home = None

  @classmethod
  def player(cls, *args):
    return pjoin(cls.players, *args)

  @classmethod
  def player_exists(cls, player):
    return os.path.isdir(cls.player(player))

  @classmethod
  def game(cls, *args):
    return pjoin(cls.games, *args)

  @classmethod
  def all_players(cls):
    return sorted([
      p for p in os.listdir(cls.players)
      if isdir(cls.player(p)) and not p.startswith('.')])

  @classmethod
  def mortems(cls, player):
    return sorted(os.listdir(cls.player(player, 'mortem')))


  @classmethod
  def scores(cls, player):
    import gzip
    import xml.etree.ElementTree as etree
    try:
      with gzip.open(cls.player(player, 'score.wad')) as fd:
        xml = etree.parse(fd)
      return [entry.attrib for entry in xml.getroot().findall('entry')]
    except FileNotFoundError:
      return []



commands = {}
class CommandRegistration(type):
  def __new__(cls, clsname, bases, attrs):
    global commands
    newclass = super().__new__(cls, clsname, bases, attrs)
    name = clsname.replace('Command', '').lower()
    if name:
      commands[name] = newclass()
    return newclass

class Command(object, metaclass=CommandRegistration):
  nargs = 0
  def run(self, *args):
    return 'Not implemented yet.'

class RegisterCommand(Command):
  """register <name> <pass> -- create a new account

  Attempts to create (and log in to) a new user account. You can spectate and
  view the high score list as a guest, but in order to actually play you need to
  register.

  The username will be used as both your login username and your DoomRL username
  (and thus will appear on the high score list) and has certain restrictions as
  a result: 24 character maximum, alphanumeric ASCII only. The password can
  contain anything, including whitespace."""

  nargs = 2

  def name_valid(self, name):
    return 0 < len(name) <= 24 and bytes(name, encoding='utf8').isalnum()

  def install(self, home, name, password):
    """Install a personal copy of DoomRL to the given path."""
    # The player gets symlinks to the doomrl binary and wad files. They get
    # their own personal backup, mortem, screenshot, and recording directories,
    # and their own personal config files (so that they can be edited). We also
    # customize config.lua with the player's name.
    for file in ['core.wad', 'doomrl', 'doomrl.wad']:
      os.symlink(pjoin(DoomRL.doomrl, file), pjoin(home, file))
    for file in os.listdir(DoomRL.config):
      shutil.copy(pjoin(DoomRL.config, file), pjoin(home, file))
    for dir in ['backup', 'mortem', 'screenshot', 'recording']:
      os.mkdir(pjoin(home, dir))
    with open(pjoin(home, 'passwd'), 'w') as passwd:
      passwd.write(password)
    with open(pjoin(home, 'config.lua'), 'a') as config:
      config.write('AlwaysName = "%s"\n' % name)


  def run(self, name, password):
    # Check name validity
    if not self.name_valid(name):
      return 'Invalid name.'

    # Check that password was specified
    if not password:
      return 'No password specified.'

    # Try to create user directory and die if we can't
    DoomRL.user = name
    home = DoomRL.player(name)
    try:
      os.mkdir(home)
    except OSError as e:
      return 'That name is unavailable.'

    # Fill in user directory
    log('Creating a new account: %s' % name)
    print('Creating user account.')
    try:
      self.install(home, name, password)
    except Exception as e:
      log('Error creating account %s: %s' % (name, e))
      print('Error creating user directory.')
      print('Report this to the server administrator.')
      try:
        shutil.rmtree(home)
      except OSError as e:
        log('Error cleaning up account %s: %s' % (name, e))
        print('Error cleaning up the half-created user directory! This username is unavailable until the admin fixes things.')
      finally:
        DoomRL.user = "guest"
        DoomRL.home = None
        return 'Unable to create user.'

    # Login
    return commands['login'].run(name, password)

class ConfigCommand(Command):
  """config <file> [reset] -- edit or reset configuration files

  As "config <file>", lets you edit one of your DoomRL configuration files.
  As "config <file> reset", lets you reset a file to defaults.
  As "config all reset", resets all files to defaults.

  Available files are:

    controls -- keyboard controls
    colours  -- game display colours
    user     -- user settings and general configuration

  Note that DoomRL has options not listed in any of these files; these options
  are overriden by the server and adding them yourself will have no effect.
  """

  nargs = 2

  def run(self, file, reset):
    if not DoomRL.home:
      return 'You must be logged in.'

    if reset and reset != 'reset':
      return 'Invalid second argument. See "help config".'

    files = frozenset(['controls', 'colours', 'user'])

    if reset and file == "all":
      print("Restoring default configuration files.")
      for file in os.listdir(DoomRL.config):
        shutil.copy(pjoin(DoomRL.config, file), pjoin(DoomRL.home, file))
      with open(pjoin(DoomRL.home, 'config.lua'), 'a') as config:
        config.write('AlwaysName = "%s"\n' % DoomRL.user)
      return

    if not file:
      print('Try "config <controls|colours|user>" or "help config".')
      return

    if file not in files:
      return 'Unknown file -- see "help config".'

    if reset:
      print('Restoring %s.lua to defaults.')
      shutil.copy(pjoin(DoomRL.config, file + '.lua'), DoomRL.home)
      return

    # Use Nano in secure mode to edit the file.
    subprocess.call(
      ['nano', '-R', pjoin(DoomRL.home, file + '.lua')])


class LoginCommand(Command):
  """login <name> <pass> -- log in to an existing account.

  This is necessary in order to actually play games. To create a new account,
  use "register"."""

  nargs = 2

  def run(self, name, password):
    if DoomRL.home:
      return 'You are already logged in!'

    if not name or not password:
      return 'You must specify both a username and a password.'

    # Check password
    home = os.path.join(DoomRL.players, name)
    try:
      with open(os.path.join(home, 'passwd')) as f:
        passwd = f.read()
      if passwd == password:
        log('%s successfully logged in.' % name)
        DoomRL.home = home
        DoomRL.user = name
        return
    except IOError as e:
      pass

    log('Failed login attempt as %s' % name)
    DoomRL.home = None
    DoomRL.user = "guest"
    return 'Login failed.'

class HelpCommand(Command):
  """help [command] -- built in help for the DoomRL server.

  With no arguments, list all commands. With a command specified, shows detailed
  help for that command."""

  nargs = 1

  def run(self, cmd):
    from inspect import getdoc

    if not cmd:
      for cmd in commands:
        print(getdoc(commands[cmd]).split('\n')[0])
      return

    if not cmd in commands:
      print('No such command. Try "help" for a list of all commands.')
    else:
      print(getdoc(commands[cmd]))

class PlayCommand(Command):
  """play [force] -- play a game of DoomRL.

  The game will automatically be recorded and made available for spectating.

  If run as 'play force', will play even if it looks like you already have a game
  in progress on another connection. Note that this will result in the recording
  for that other game being lost, and potentially in DoomRL high score/player
  rank information being lost as well."""

  nargs = 1

  def setup(self):
    # If the player has a game in progress, restore their ttyrec file.
    if exists(self.recfile + '.save'):
      os.rename(self.recfile + '.save', recfile)
      print('Recording of current game restored.')

    # Get their pre-game high scores so we can check for new ones afterwards.
    scores_before = DoomRL.scores(DoomRL.user)
    try:
      mortem_before = DoomRL.mortems(DoomRL.user)[-1]
    except IndexError:
      mortem_before = None

    return (scores_before,mortem_before)

  def run_doomrl(self):
    # Invoke DoomRL inside ttyrec. Rather than letting ttyrec write directly
    # to disk, we hand it an FD and then process the contents of that fd.
    #(rpipe,wpipe) = os.pipe()
    #os.set_inheritable(wpipe)
    ttyrec = subprocess.call(
      ['ttyrec', '-e', './doomrl', '-a', self.recfile], # '/dev/fd/%d' % wpipe
      cwd=DoomRL.home)

    # Now we read from the pipe and process the output until it's closed,
    # stripping out garbage frames and writing the rest to disk.
    #with open(ttyrec, "r") as fd:

  def run(self, force):
    if not DoomRL.home:
      return 'You must log in first.'

    # Check that they aren't already playing *right now*.
    self.recfile = DoomRL.game(DoomRL.user)
    if exists(self.recfile):
      if not force == 'force':
        return 'You have a game already in progress! Disconnect that session first.'
      print('You have a game already in progress! Deleting existing recording and continuing.')
      os.remove(self.recfile)

    (scores,mortem) = self.setup()
    self.run_doomrl()
    self.shutdown(scores, mortem)

  def shutdown(self, scores_before, mortem_before):
    # If the game is still in progress, save the ttyrec file.
    if exists(DoomRL.player(DoomRL.user, 'save')):
      os.rename(self.recfile, self.recfile + '.save')
    else:
      # Otherwise, there *should* be a new high score entry and a new mortem.
      # Unless they simply didn't start a game in the first place.
      try:
        mortem = DoomRL.mortems(DoomRL.user)[-1]
      except IndexError:
        mortem = None

      if mortem == mortem_before:
        # No new postmortem created and no save file means no game played.
        os.remove(DoomRL.game(DoomRL.user))
        return

      when = mortem[1:20]
      scores_after = DoomRL.scores(DoomRL.user)
      for (i,score) in enumerate(scores_after):
        if i >= len(scores_before) or scores_before[i] != score:
          # Write the scoreline to the last line of the mortem so that we can
          # easily match it up later when generating the HTML interface.
          with open(pjoin(DoomRL.home, 'mortem', mortem), 'a') as fd:
            fd.write(str(score) + '\n')
          break

      # We also save the ttyrec file, using the date from the postmortem.
      ttyrec = '[%s] %s.ttyrec' % (when, DoomRL.user)
      os.rename(
        DoomRL.game(DoomRL.user),
        pjoin(DoomRL.home, 'recording', ttyrec))

class WatchCommand(Command):
  """watch <player> -- watch an in-progress game of DoomRL.

  With no arguments, lists all currently active games. With the name of a
  player, spectates that player's game.

  The replay has an initial 'catch-up' phase where it replays the game so far
  at 64x normal speed. During this period the normal replay controls (see
  "help replay") will work. At any point you can exit spectator mode with ctrl-C.

  If the person you are spectating exits, the screen will go black and won't
  automatically return to the prompt -- this is a limitation of the underlying
  software used for replays. Once this happens, press ctrl-C to exit.
  """

  nargs = 1

  def run(self, player):
    if not player:
      # list active games
      print('SECONDS PLAYER')
      for player in DoomRL.all_players():
        if exists(DoomRL.game(player)):
          subprocess.call(['ttytime', player], cwd=DoomRL.games)
      return

    if not exists(DoomRL.game(player)):
      return 'No game in progress under that name.'

    try:
      # First we 'catch up' by playing the game so far at 16x speed.
      subprocess.call(
        ['ttyplay', '-s', '16', player],
        cwd=DoomRL.games)
      # Then we peek at what remains.
      subprocess.call(
        ['ttyplay', '-p', player],
        cwd=DoomRL.games)
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class ReplayCommand(Command):
  """replay <player> <number> -- replay a recorded game

  With no arguments, lists all players with recorded games. With a player name,
  lists the recorded games for that player. With a name and a replay number,
  replays the given name. The replay number can be found out from the list of
  that player's replays.

  You can also use "latest" to view the latest replay for that player.

  If you know the exact timestamp of the replay (also given in the list), you
  can use that in place of the replay number.

  Replay controls:
    f or +: go faster
    s or -: go slower
    1: reset speed
    ctrl-c: exit replay
    anything else: skip to the next player input (useful for long idle periods)
  """

  nargs = 2

  def replays(self, player):
    return sorted(os.listdir(DoomRL.player(player, 'recording')))

  def list_players(self):
    """List all players with recordings, and how many."""
    print(' NUM  PLAYER')
    for player in DoomRL.all_players():
      replays = len(self.replays(player))
      if replays > 0:
        print('%4d  %s' % (replays, player))

  def list_replays(self, player):
    """List all recordings for this player."""
    print('  ID  TIME')
    for (index, replay) in enumerate(self.replays(player)):
      print('%4d  %s' % (index, replay[1:20]))

  def run(self, player, id):
    if not player:
      return self.list_players()
    elif not DoomRL.player_exists(player):
      return 'No such player: %s' % player
    elif not id:
      return self.list_replays(player)

    # Replay the named recording.
    replays = self.replays(player)
    if id == "latest":
      recname = replays[-1]
    else:
      try:
        recname = replays[int(id)]
      except:
        recname = '[%s] %s.ttyrec' % (id, player)

    if not exists(DoomRL.player(player, 'recording', recname)):
      return 'No such replay found.'

    try:
      subprocess.call(
        ['ttyplay', recname],
        cwd=DoomRL.player(player, 'recording'))
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class ScoresCommand(Command):
  """scores [player] -- show high score list

  With no arguments, show the entire scoreboard. With a given player, show only
  scores for that player. Use the arrow keys or pageup/down to scroll, and q to
  quit.

  Note that due to restrictions on how DoomRL stores the high score list, the
  in-game high scores will always only show your own."""

  nargs = 1

  def run(self, player):
    if not player:
      scores = []
      for player in DoomRL.all_players():
        scores += DoomRL.scores(player)
    else:
      scores = DoomRL.scores(player)

    scores.sort(reverse=True, key=lambda s: int(s['score']))

    difficulties = ['', 'E', 'M', 'H', 'U', 'N!']
    classes = { 'marine': 'M', 'scout': 'S', 'technician': 'T' }
    less = subprocess.Popen(
      ['less'],
      universal_newlines=True,
      env={'LESSSECURE': '1', 'TERM': os.getenv('TERM')},
      stdin=subprocess.PIPE)
    for score in scores:
      less.stdin.write(' %2s %7s %-24s %sL:%-2s %-34s L%-2s %s\n' % (
        difficulties[int(score['difficulty'])],
        score['score'],
        score['name'],
        classes[score['klass']],
        score['level'],
        score['killed'],
        score['depth'],
        score.get('challenge', '')))
    less.stdin.close()
    less.wait()

class MortemCommand(Command):
  """mortem <player> <number> -- view a postmortem

  With no arguments, lists all players with postmortems. With a player name,
  lists the available postmortems. With a number or date, view that postmortem.

  You can also use "latest" to view the latest postmortem for that player.

  The viewer used is less(1). Use pageup/down or the arrow keys to scroll, q to
  quit. You can press h or H at any time for help.
  """

  nargs = 2

  def list_players(self):
    """List all players with mortems, and how many."""
    print(' NUM  PLAYER')
    for player in DoomRL.all_players():
      mortems = len(DoomRL.mortems(player))
      if mortems > 0:
        print('%4d  %s' % (mortems, player))

  def list_mortems(self, player):
    """List all mortems for this player."""
    print('  ID  TIME')
    for (index, mortem) in enumerate(DoomRL.mortems(player)):
      print('%4d  %s' % (index, mortem[1:20]))

  def run(self, player, id):
    if not player:
      return self.list_players()
    elif not id:
      return self.list_mortems(player)

    mortems = DoomRL.mortems(player)
    if id == "latest":
      mortem = mortems[-1]
    else:
      try:
        mortem = mortems[int(id)]
      except:
        mortem = '[%s] %s.txt' % (id, player)

    if not exists(DoomRL.player(player, 'mortem', mortem)):
      return 'No such mortem found.'

    try:
      subprocess.call(
        ['less', '-d', '-M', mortem],
        cwd=DoomRL.player(player, 'mortem'),
        env={
          'LESSSECURE': '1',
          'TERM': os.getenv('TERM')
        })
    except KeyboardInterrupt:
      pass
    finally:
      pass
      #subprocess.call(['reset'])


def sighup(sig, frame):
  """Signal handler for SIGHUP, which is raised when the user disconnects suddenly."""
  # If we got interrupted halfway through creating the player's profile, then
  # DoomRL.user will be set and DoomRL.home won't be (a normal login sets them
  # in the opposite order, so if we get interrupted halfway through login it's
  # safe). In that case we should remove the half-constructed player profile
  # so that the name can be re-used.
  if DoomRL.user != 'guest' and not DoomRL.home:
    shutil.rmtree(DoomRL.player(DoomRL.user), ignore_errors=True)
    return

  if DoomRL.home and DoomRL.user:
    # If we got interrupted while the player was actually in DoomRL, there's a
    # ttyrec file. It's possible they did something super cool before everything
    # went sideways, so we should save it.
    try:
      when = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')
      what = '[%s] %s.ttyrec' % (when, DoomRL.user)
      os.rename(
        DoomRL.game(DoomRL.user),
        pjoin(DoomRL.home, 'recording', what))
    except FileNotFoundError:
      pass


def argsplit(string, max=2):
  args = string.split(maxsplit=max-1)
  while len(args) < max:
    args.append('')
  return args

def main():
  from signal import signal,SIGHUP
  signal(SIGHUP, sighup)

  syslog.openlog('doomrl-server', facility=syslog.LOG_DAEMON)

  print("""
=================     ===============     ===============   ========  ========
\\\\ . . . . . . .\\\\   //. . . . . . .\\\\   //. . . . . . .\\\\  \\\\. . .\\\\// . . //
||. . ._____. . .|| ||. . ._____. . .|| ||. . ._____. . .|| || . . .\/ . . .||
|| . .||   ||. . || || . .||   ||. . || || . .||   ||. . || ||. . . . . . . ||
||. . ||   || . .|| ||. . ||   || . .|| ||. . ||   || . .|| || . | . . . . .||
|| . .||   ||. _-|| ||-_ .||   ||. . || || . .||   ||. _-|| ||-_.|\ . . . . ||
||. . ||   ||-'  || ||  `-||   || . .|| ||. . ||   ||-'  || ||  `|\_ . .|. .||
|| . _||   ||    || ||    ||   ||_ . || || . _||   ||    || ||   |\ `-_/| . ||
||_-' ||  .|/    || ||    \|.  || `-_|| ||_-' ||  .|/    || ||   | \  / |-_.||
||    ||_-'      || ||      `-_||    || ||    ||_-'      || ||   | \  / |  `||
||    `'         || ||         `'    || ||    `'         || ||   | \  / |   ||
||            .===' `===.         .==='.`===.         .===' /==. |  \/  |   ||
||         .=='   \_|-_ `===. .==='   _|_   `===. .===' _-|/   `==  \/  |   ||
||      .=='    _-'    `-_  `='    _-'   `-_    `='  _-'   `-_  /|  \/  |   ||
||   .=='    _-'          `-__\._-'         `-_./__-'         `' |. /|  |   ||
||.=='    _-'                                                     `' |  /==.||
=='    _-'               DoomRL by Kornel Kisielewicz                 \/   `==
\   _-'                   DoomRL Server by Ben Kelly                   `-_   /
 `''                                                                      ``'

Type 'help' for a list of commands.""")

  try:
    import os
    (rows, columns) = os.popen('stty size', 'r').read().split()
    if int(rows) < 25 or int(columns) < 80:
      print("Warning: your terminal size (%sx%s) is smaller than the 80x25"
            " needed by DoomRL. The 'play', 'replay', and 'watch' commands"
            " may not work correctly." % (columns, rows))
  except Exception:
    print("Warning: unable to determine terminal size.")

  while True:
    try:
      [cmd, args] = argsplit(input('\n%s> ' % DoomRL.user).strip())
      if cmd in commands:
        result = commands[cmd].run(*argsplit(args, max=commands[cmd].nargs))
        if result:
          print('Error: %s' % result)
      elif cmd == 'quit':
        break
      elif not cmd:
        pass
      else:
        print('Error: Unrecognized command. Try "help".')
    except EOFError as e:
      break
    except KeyboardInterrupt:
      pass
    except Exception as e:
      log('Unhandled exception in mainloop: %s' % str(e))

  if DoomRL.home:
    log('User %s logged out.' % DoomRL.user)
  print('Goodbye!')

if __name__ == '__main__':
  main()
