#!/usr/bin/python3

import datetime
import os
import readline
import shutil
import subprocess

from os.path import join as pjoin
from os.path import exists

# DoomRL loads score.wad and player.wad on startup, holds them in memory for its
# entire run, and writes them out on exit.
# Score.wad is a gzipped XML file containing the scores. It starts with a CRC,
# and if this CRC is incorrect, will attempt to restore score.wad from backup
# or, failing that, erase it and start over. So merging score.wad is a no-go
# unless we can reverse engineer the CRC. It looks the right size to be md5.

class DoomRL(object):
  # Set up paths
  root = os.getenv('DOOMRL_SERVER') or os.getenv('HOME')
  config = pjoin(root, 'config')
  doomrl = pjoin(root, 'doomrl')
  games = pjoin(root, 'games')
  players = pjoin(root, 'players')
  www = pjoin(root, 'www')
  # Global state
  user = 'guest'
  home = None

  @classmethod
  def player(cls, *args):
    return pjoin(cls.players, *args)

  @classmethod
  def game(cls, *args):
    return pjoin(cls.games, *args)

  @classmethod
  def all_players(cls):
    return sorted([p for p in os.listdir(cls.players) if not p.startswith('.')])

  @classmethod
  def scores(cls, player):
    import gzip
    import xml.etree.ElementTree as etree
    scores = []
    with gzip.open(cls.player(player, 'score.wad')) as fd:
      xml = etree.parse(fd)
    return [entry.attrib for entry in xml.getroot().findall('entry')]



commands = {}
class CommandRegistration(type):
  def __new__(cls, clsname, bases, attrs):
    global commands
    newclass = super().__new__(cls, clsname, bases, attrs)
    name = clsname.replace('Command', '').lower()
    if name:
      commands[name] = newclass()
    return newclass

class Command(object, metaclass=CommandRegistration):
  nargs = 0
  def run(self, *args):
    return 'Not implemented yet.'

class RegisterCommand(Command):
  """register <name> <pass> -- create a new account

  Attempts to create (and log in to) a new user account. You can spectate and
  view the high score list as a guest, but in order to actually play you need to
  register.

  The username will be used as both your login username and your DoomRL username
  (and thus will appear on the high score list) and has certain restrictions as
  a result: 24 character maximum, alphanumeric ASCII only. The password can
  contain anything, including whitespace."""

  nargs = 2

  def name_valid(self, name):
    return 0 < len(name) <= 24 and bytes(name, encoding='utf8').isalnum()

  def install(self, home, name, password):
    """Install a personal copy of DoomRL to the given path."""
    # The player needs their own personal player.wad, score.wad, and backup,
    # mortem and screenshot directories.
    # They also need a personalized name.lua that is generated on the fly.
    # They get symlinks to colors.lua, config.lua, core.wad, doomrl, doomrl.wad,
    # and keybindings.lua.
    for file in ['player.wad', 'score.wad']:
      shutil.copy(pjoin(DoomRL.doomrl, file), home)
    for file in ['core.wad', 'doomrl', 'doomrl.wad']:
      os.symlink(pjoin(DoomRL.doomrl, file), pjoin(home, file))
    for file in ['colors.lua', 'config.lua', 'keybindings.lua']:
      os.symlink(pjoin(DoomRL.config, file), pjoin(home, file))
    for dir in ['backup', 'mortem', 'screenshot', 'recording']:
      os.mkdir(pjoin(home, dir))
    with open(pjoin(home, 'passwd'), 'w') as passwd:
      passwd.write(password)
    with open(pjoin(home, 'user.lua'), 'w') as config:
      config.write('AlwaysName = "%s"\n' % name)


  def run(self, name, password):
    # Check name validity
    if not self.name_valid(name):
      return 'Invalid name.'

    # Check that password was specified
    if not password:
      return 'No password specified.'

    # Try to create user directory and die if we can't
    print('Creating user account.')
    DoomRL.user = name
    home = DoomRL.player(name)
    try:
      os.mkdir(home)
    except OSError as e:
      return 'Unable to create user directory; most likely this name is already in use.'

    # Fill in user directory
    try:
      self.install(home, name, password)
    except Exception as e:
      print('Error creating user directory: %s', e)
      print('Report this to the server administrator.')
      try:
        shutil.rmtree(home)
      except OSError as e:
        print('Error cleaning up the half-created user directory! This usename is unavailable until the admin fixes things.')
      finally:
        return 'Unable to create user.'

    # Login
    return commands['login'].run(name, password)

class LoginCommand(Command):
  """login <name> <pass> -- log in to an existing account.

  This is necessary in order to actually play games. To create a new account,
  use "register"."""

  nargs = 2

  def run(self, name, password):
    if DoomRL.home:
      return 'You are already logged in!'

    if not name or not password:
      return 'You must specify both a username and a password.'

    # Check password
    home = os.path.join(DoomRL.players, name)
    try:
      with open(os.path.join(home, 'passwd')) as f:
        passwd = f.read()
    except IOError as e:
      return 'Login failed.'

    if passwd != password:
      print(passwd, password)
      return 'Login failed.'

    DoomRL.home = home
    DoomRL.user = name

class HelpCommand(Command):
  """help [command] -- built in help for the DoomRL server.

  With no arguments, list all commands. With a command specified, shows detailed
  help for that command."""

  nargs = 1

  def run(self, cmd):
    from inspect import getdoc

    if not cmd:
      for cmd in commands:
        print(getdoc(commands[cmd]).split('\n')[0])
      return

    if not cmd in commands:
      print('No such command. Try "help" for a list of all commands.')
    else:
      print(getdoc(commands[cmd]))

class PlayCommand(Command):
  """play [force] -- play a game of DoomRL.

  The game will automatically be recorded and made available for spectating.

  If run as 'play force', will play even if it looks like you already have a game
  in progress on another connection. Note that this will result in the recording
  for that other game being lost, and potentially in DoomRL high score/player
  rank information being lost as well."""

  nargs = 1

  def run(self, force):
    if not DoomRL.home:
      return 'You must log in first.'

    # Check that they aren't already playing *right now*.
    recfile = DoomRL.game(DoomRL.user)
    if exists(recfile):
      if not force == 'force':
        return 'You have a game already in progress! Disconnect that session first.'
      print('You have a game already in progress! Deleting existing recording and continuing.')
      os.remove(recfile)

    # If the player has a game in progress, restore their ttyrec file.
    if exists(recfile + '.save'):
      os.rename(recfile + '.save', recfile)
      print('Recording of current game restored.')

    # Invoke DoomRL.
    subprocess.call(
      ['ttyrec', '-e', './doomrl', '-a', recfile],
      cwd=DoomRL.home)

    # If the game is still in progress, save the ttyrec file.
    if exists(recfile + '.save'):
      os.rename(recfile, recfile + '.save')
    else:
      # Otherwise, archive it under an appropriate name.
      # FIXME: this should check the mortem directory and make sure that the
      # timestamps match up.
      when = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')
      what = '[%s] %s.ttyrec' % (when, DoomRL.user)
      os.rename(
        DoomRL.game(DoomRL.user),
        pjoin(DoomRL.home, 'recording', what))

class WatchCommand(Command):
  """watch <player> -- watch an in-progress game of DoomRL.

  With no arguments, lists all currently active games. With the name of a
  player, spectates that player's game.

  The replay has an initial 'catch-up' phase where it replays the game so far
  at 64x normal speed. During this period the normal replay controls (see
  "help replay") will work. At any point you can exit spectator mode with ctrl-C.

  If the person you are spectating exits, the screen will go black and won't
  automatically return to the prompt -- this is a limitation of the underlying
  software used for replays. Once this happens, press ctrl-C to exit.
  """

  nargs = 1

  def run(self, player):
    if not player:
      # list active games
      print('SECONDS PLAYER')
      for player in DoomRL.all_players():
        if exists(DoomRL.game(player)):
          subprocess.call(['ttytime', player], cwd=DoomRL.games)
      return

    if not exists(DoomRL.game(player)):
      return 'No game in progress under that name.'

    try:
      # First we 'catch up' by playing the game so far at 16x speed.
      subprocess.call(
        ['ttyplay', '-s', '16', player],
        cwd=DoomRL.games)
      # Then we peek at what remains.
      subprocess.call(
        ['ttyplay', '-p', player],
        cwd=DoomRL.games)
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class ReplayCommand(Command):
  """replay <player> <number> -- replay a recorded game

  With no arguments, lists all players with recorded games. With a player name,
  lists the recorded games for that player. With a name and a replay number,
  replays the given name. The replay number can be found out from the list of
  that player's replays.

  If you know the exact timestamp of the replay (also given in the list), you
  can use that in place of the replay number.

  Replay controls:
    f or +: go faster
    s or -: go slower
    1: reset speed
    ctrl-c: exit replay
    anything else: skip to the next player input (useful for long idle periods)
  """

  nargs = 2

  def replays(self, player):
    return sorted(os.listdir(DoomRL.player(player, 'recording')))

  def list_players(self):
    """List all players with recordings, and how many."""
    print(' NUM  PLAYER')
    for player in DoomRL.all_players():
      replays = len(self.replays(player))
      if replays > 0:
        print('%4d  %s' % (replays, player))

  def list_replays(self, player):
    """List all recordings for this player."""
    print('  ID  TIME')
    for (index, replay) in enumerate(self.replays(player)):
      print('%4d  %s' % (index, replay[1:20]))

  def run(self, player, id):
    if not player:
      return self.list_players()
    elif not id:
      return self.list_replays(player)

    # Replay the named recording.
    replays = self.replays(player)
    recname = '[%s] %s.ttyrec' % (id, player)
    try:
      recname = replays[int(id)]
    except:
      pass

    if not exists(DoomRL.player(player, 'recording', recname)):
      return 'No such replay found.'

    try:
      subprocess.call(
        ['ttyplay', recname],
        cwd=DoomRL.player(player, 'recording'))
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class ScoresCommand(Command):
  """scores [player] -- show high score list

  With no arguments, show the entire scoreboard. With a given player, show only
  scores for that player.

  Note that due to restrictions on how DoomRL stores the high score list, the
  in-game high scores will always only show your own."""

  nargs = 1

  def run(self, player):
    if not player:
      scores = []
      for player in DoomRL.all_players():
        scores += DoomRL.scores(player)
    else:
      scores = DoomRL.scores(player)

    scores.sort(key=lambda s: int(s['score']))

    difficulties = ['', 'E', 'M', 'H', 'U', 'N!']
    classes = { 'marine': 'M', 'scout': 'S', 'technician': 'T' }
    for score in scores:
      print(' %2s %7s %-24s %sL:%-2s %-34s L%-2s %s' % (
        difficulties[int(score['difficulty'])],
        score['score'],
        score['name'],
        classes[score['klass']],
        score['level'],
        score['killed'],
        score['depth'],
        score.get('challenge', '')
        ))


def sighup(sig, frame):
  """Signal handler for SIGHUP, which is raised when the user disconnects suddenly."""
  # If we got interrupted halfway through creating the player's profile, then
  # DoomRL.user will be set and DoomRL.home won't be (a normal login sets them
  # in the opposite order, so if we get interrupted halfway through login it's
  # safe). In that case we should remove the half-constructed player profile
  # so that the name can be re-used.
  if DoomRL.user != 'guest' and not DoomRL.home:
    shutil.rmtree(DoomRL.player(DoomRL.user), ignore_errors=True)
    return

  if DoomRL.home and DoomRL.user:
    # If we got interrupted while the player was actually in DoomRL, there's a
    # ttyrec file. It's possible they did something super cool before everything
    # went sideways, so we should save it.
    try:
      when = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')
      what = '[%s] %s.ttyrec' % (when, DoomRL.user)
      os.rename(
        DoomRL.game(DoomRL.user),
        pjoin(DoomRL.home, 'recording', what))
    except FileNotFoundError:
      pass


def argsplit(string, max=2):
  args = string.split(maxsplit=max-1)
  while len(args) < max:
    args.append('')
  return args

def main():
  from signal import signal,SIGHUP
  signal(SIGHUP, sighup)

  print("""
=================     ===============     ===============   ========  ========
\\\\ . . . . . . .\\\\   //. . . . . . .\\\\   //. . . . . . .\\\\  \\\\. . .\\\\// . . //
||. . ._____. . .|| ||. . ._____. . .|| ||. . ._____. . .|| || . . .\/ . . .||
|| . .||   ||. . || || . .||   ||. . || || . .||   ||. . || ||. . . . . . . ||
||. . ||   || . .|| ||. . ||   || . .|| ||. . ||   || . .|| || . | . . . . .||
|| . .||   ||. _-|| ||-_ .||   ||. . || || . .||   ||. _-|| ||-_.|\ . . . . ||
||. . ||   ||-'  || ||  `-||   || . .|| ||. . ||   ||-'  || ||  `|\_ . .|. .||
|| . _||   ||    || ||    ||   ||_ . || || . _||   ||    || ||   |\ `-_/| . ||
||_-' ||  .|/    || ||    \|.  || `-_|| ||_-' ||  .|/    || ||   | \  / |-_.||
||    ||_-'      || ||      `-_||    || ||    ||_-'      || ||   | \  / |  `||
||    `'         || ||         `'    || ||    `'         || ||   | \  / |   ||
||            .===' `===.         .==='.`===.         .===' /==. |  \/  |   ||
||         .=='   \_|-_ `===. .==='   _|_   `===. .===' _-|/   `==  \/  |   ||
||      .=='    _-'    `-_  `='    _-'   `-_    `='  _-'   `-_  /|  \/  |   ||
||   .=='    _-'          `-__\._-'         `-_./__-'         `' |. /|  |   ||
||.=='    _-'                                                     `' |  /==.||
=='    _-'               DoomRL by Kornel Kisielewicz                 \/   `==
\   _-'                   DoomRL Server by Ben Kelly                   `-_   /
 `''                                                                      ``'

Type 'help' for a list of commands.""")

  try:
    import os
    (rows, columns) = os.popen('stty size', 'r').read().split()
    if int(rows) < 25 or int(columns) < 80:
      print("Warning: your terminal size (%sx%s) is smaller than the 80x25"
            " needed by DoomRL. The 'play', 'replay', and 'watch' commands"
            " may not work correctly." % (columns, rows))
  except Exception:
    print("Warning: unable to determine terminal size.")

  while True:
    try:
      [cmd, args] = argsplit(input('\n%s> ' % DoomRL.user))
      if cmd in commands:
        result = commands[cmd].run(*argsplit(args, max=commands[cmd].nargs))
        if result:
          print('Error: %s' % result)
      elif cmd == 'quit':
        break
      elif not cmd:
        pass
      else:
        print('Error: Unrecognized command. Try "help".')
    except EOFError as e:
      break
    except KeyboardInterrupt:
      pass
  print('Goodbye!')

if __name__ == '__main__':
  main()
