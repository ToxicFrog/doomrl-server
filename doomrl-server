#!/usr/bin/python3

import datetime
import os
import readline
import shutil
import subprocess

from os.path import join as pjoin

# DoomRL loads score.wad and player.wad on startup, holds them in memory for its
# entire run, and writes them out on exit.
# Score.wad is a gzipped XML file containing the scores. It starts with a CRC,
# and if this CRC is incorrect, will attempt to restore score.wad from backup
# or, failing that, erase it and start over. So merging score.wad is a no-go
# unless we can reverse engineer the CRC. It looks the right size to be md5.

class DoomRL(object):
  # Set up paths
  root = os.getenv('DOOMRL_SERVER') or os.getenv('HOME')
  config = pjoin(root, 'config')
  doomrl = pjoin(root, 'doomrl')
  games = pjoin(root, 'games')
  players = pjoin(root, 'players')
  www = pjoin(root, 'www')
  # Global state
  user = 'guest'
  home = None

commands = {}
class CommandRegistration(type):
  def __new__(cls, clsname, bases, attrs):
    global commands
    newclass = super().__new__(cls, clsname, bases, attrs)
    name = clsname.replace('Command', '').lower()
    if name:
      commands[name] = newclass()
    return newclass

class Command(object, metaclass=CommandRegistration):
  nargs = 0
  def run(self, *args):
    return 'Not implemented yet.'

class RegisterCommand(Command):
  """register <name> <pass> -- create a new account

  Attempts to create (and log in to) a new user account. You can spectate and
  view the high score list as a guest, but in order to actually play you need to
  register.

  The username will be used as both your login username and your DoomRL username
  (and thus will appear on the high score list) and has certain restrictions as
  a result: 24 character maximum, alphanumeric ASCII only. The password can
  contain anything, including whitespace."""

  nargs = 2

  def name_valid(self, name):
    return 0 < len(name) <= 24 and bytes(name, encoding='utf8').isalnum()

  def install(self, home, name, password):
    """Install a personal copy of DoomRL to the given path."""
    # The player needs their own personal player.wad, score.wad, and backup,
    # mortem and screenshot directories.
    # They also need a personalized name.lua that is generated on the fly.
    # They get symlinks to colors.lua, config.lua, core.wad, doomrl, doomrl.wad,
    # and keybindings.lua.
    for file in ['player.wad', 'score.wad']:
      shutil.copy(pjoin(DoomRL.doomrl, file), home)
    for file in ['core.wad', 'doomrl', 'doomrl.wad']:
      os.symlink(pjoin(DoomRL.doomrl, file), pjoin(home, file))
    for file in ['colors.lua', 'config.lua', 'keybindings.lua']:
      os.symlink(pjoin(DoomRL.config, file), pjoin(home, file))
    for dir in ['backup', 'mortem', 'screenshot', 'recording']:
      os.mkdir(pjoin(home, dir))
    with open(pjoin(home, 'passwd'), 'w') as passwd:
      passwd.write(password)
    with open(pjoin(home, 'user.lua'), 'w') as config:
      config.write('AlwaysName = "%s"\n' % name)


  def run(self, name, password):
    # Check name validity
    if not self.name_valid(name):
      return 'Invalid name.'

    # Check that password was specified
    if not password:
      return 'No password specified.'

    # Try to create user directory and die if we can't
    print('Creating user account.')
    DoomRL.user = name
    home = pjoin(DoomRL.players, name)
    try:
      os.mkdir(home)
    except OSError as e:
      return 'Unable to create user directory; most likely this name is already in use.'

    # Fill in user directory
    try:
      self.install(home, name, password)
    except Exception as e:
      print('Error creating user directory: %s', e)
      print('Report this to the server administrator.')
      try:
        shutil.rmtree(home)
      except OSError as e:
        print('Error cleaning up the half-created user directory! This usename is unavailable until the admin fixes things.')
      finally:
        return 'Unable to create user.'

    # Login
    return commands['login'].run(name, password)

class LoginCommand(Command):
  """login <name> <pass> -- log in to an existing account.

  This is necessary in order to actually play games. To create a new account,
  use "register"."""

  nargs = 2

  def run(self, name, password):
    if DoomRL.home:
      return 'You are already logged in!'

    if not name or not password:
      return 'You must specify both a username and a password.'

    # Check password
    home = os.path.join(DoomRL.players, name)
    try:
      with open(os.path.join(home, 'passwd')) as f:
        passwd = f.read()
    except IOError as e:
      return 'Login failed.'

    if passwd != password:
      print(passwd, password)
      return 'Login failed.'

    DoomRL.home = home
    DoomRL.user = name

class HelpCommand(Command):
  """help [command] -- built in help for the DoomRL server.

  With no arguments, list all commands. With a command specified, shows detailed
  help for that command."""

  nargs = 1

  def run(self, cmd):
    from inspect import getdoc

    if not cmd:
      for cmd in commands:
        print(getdoc(commands[cmd]).split('\n')[0])
      return

    if not cmd in commands:
      print('No such command. Try "help" for a list of all commands.')
    else:
      print(getdoc(commands[cmd]))

class PlayCommand(Command):
  """play [force] -- play a game of DoomRL.

  The game will automatically be recorded and made available for spectating.

  If run as 'play force', will play even if it looks like you already have a game
  in progress on another connection. Note that this will result in the recording
  for that other game being lost, and potentially in DoomRL high score/player
  rank information being lost as well."""

  nargs = 1

  def run(self, force):
    if not DoomRL.home:
      return 'You must log in first.'

    # Check that they aren't already playing *right now*.
    recfile = pjoin(DoomRL.games, DoomRL.user)
    try:
      os.stat(recfile)
      if not force == 'force':
        return 'You have a game already in progress! Disconnect that session first.'
      print('You have a game already in progress! Deleting existing recording and continuing.')
      os.remove(recfile)
    except FileNotFoundError:
      pass

    # If the player has a game in progress, restore their ttyrec file.
    try:
      os.rename(recfile + ".save", recfile)
      print('Recording of current game restored.')
    except FileNotFoundError:
      pass

    # Invoke DoomRL.
    subprocess.call(
      ['ttyrec', '-e', './doomrl', '-a', recfile],
      cwd=DoomRL.home)

    # If the game is still in progress, save the ttyrec file.
    try:
      os.stat(pjoin(DoomRL.home, 'save'))
      os.rename(recfile, recfile + '.save')
    except FileNotFoundError:
      # Otherwise, archive it under an appropriate name.
      # FIXME: this should check the mortem directory and make sure that the
      # timestamps match up.
      when = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')
      what = '[%s] %s.ttyrec' % (when, DoomRL.user)
      os.rename(
        pjoin(DoomRL.games, DoomRL.user),
        pjoin(DoomRL.home, 'recording', what))

class WatchCommand(Command):
  """watch <player> -- watch an in-progress game of DoomRL.

  With no arguments, lists all currently active games. With the name of a
  player, spectates that player's game."""

  nargs = 1

class ReplayCommand(Command):
  """replay <player> <time> -- replay a recorded game

  With no arguments, lists all players with recorded games. With a player name,
  lists the recorded games for that player. With a name and a date/time stamp,
  replays that game.

  Replay controls:
    f or +: go faster
    s or -: go slower
    1: reset speed to realtime
    anything else: skip to the next player input (useful for long idle periods)
  """

  nargs = 2

def sighup(sig, frame):
  """Signal handler for SIGHUP, which is raised when the user disconnects suddenly."""
  # If we got interrupted halfway through creating the player's profile, then
  # DoomRL.user will be set and DoomRL.home won't be (a normal login sets them
  # in the opposite order, so if we get interrupted halfway through login it's
  # safe). In that case we should remove the half-constructed player profile
  # so that the name can be re-used.
  if DoomRL.user != 'guest' and not DoomRL.home:
    shutil.rmtree(pjoin(DoomRL.players, DoomRL.user), ignore_errors=True)
    return

  if DoomRL.home and DoomRL.user:
    # If we got interrupted while the player was actually in DoomRL, there's a
    # ttyrec file. It's possible they did something super cool before everything
    # went sideways, so we should save it.
    try:
      when = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')
      what = '[%s] %s (disconnected).ttyrec' % (when, DoomRL.user)
      os.rename(
        pjoin(DoomRL.games, DoomRL.user),
        pjoin(DoomRL.home, 'recording', what))
    except FileNotFoundError:
      pass


def argsplit(string, max=2):
  args = string.split(maxsplit=max-1)
  while len(args) < max:
    args.append('')
  return args

def main():
  from signal import signal,SIGHUP
  signal(SIGHUP, sighup)

  while True:
    try:
      [cmd, args] = argsplit(input('\n%s> ' % DoomRL.user))
      if cmd in commands:
        result = commands[cmd].run(*argsplit(args, max=commands[cmd].nargs))
        if result:
          print('Error: %s' % result)
      elif cmd == 'quit':
        break
      elif not cmd:
        pass
      else:
        print('Error: Unrecognized command. Try "help".')
    except EOFError as e:
      break
  print('Goodbye!')

if __name__ == '__main__':
  main()
