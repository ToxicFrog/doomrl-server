#!/usr/bin/python3

import datetime
import os
import re
import readline
import shutil
import subprocess
import sys
import syslog

from os.path import join as pjoin
from os.path import exists,isdir
from struct import pack,unpack
from syslog import syslog as log
from time import time

# DoomRL loads score.wad and player.wad on startup, holds them in memory for its
# entire run, and writes them out on exit.
# Score.wad is a gzipped XML file containing the scores. It starts with a CRC,
# and if this CRC is incorrect, will attempt to restore score.wad from backup
# or, failing that, erase it and start over. So merging score.wad is a no-go
# unless we can reverse engineer the CRC. It looks the right size to be md5.

class DoomRL(object):
  """Global state for the DoomRL server."""
  # Set up paths
  root = os.getenv('DOOMRL_SERVER') or os.path.dirname(os.path.realpath(__file__))
  config = pjoin(root, 'config')
  doomrl = pjoin(root, 'doomrl')
  games = pjoin(root, 'games')
  players = pjoin(root, 'players')
  www = pjoin(root, 'www')
  # Global state
  user = 'guest'
  home = None

  @classmethod
  def name_valid(cls, name):
    """Check if a player or game name is legal."""
    return 0 < len(name) <= 24 and bytes(name, encoding='utf8').isalnum()

  @classmethod
  def homedir(cls, *args):
    return pjoin(cls.home, *args)

  @classmethod
  def player(cls, *args):
    """Get the directory for a given player."""
    return pjoin(cls.players, *args)

  @classmethod
  def player_exists(cls, player):
    """Check if a player exists."""
    return os.path.isdir(cls.player(player))

  @classmethod
  def game(cls, *args):
    """Get a game-in-progress replay file."""
    return pjoin(cls.games, *args)

  @classmethod
  def all_players(cls):
    """A list of all players."""
    return sorted([
      p for p in os.listdir(cls.players)
      if isdir(cls.player(p)) and not p.startswith('.')])

  @classmethod
  def mortems(cls, player):
    """A list of all mortems for a given player."""
    return sorted(os.listdir(cls.player(player, 'mortem')))

  @classmethod
  def scores(cls, player):
    """A list of all highscore entries for a given player."""
    import gzip
    import xml.etree.ElementTree as etree
    try:
      with gzip.open(cls.player(player, 'score.wad')) as fd:
        xml = etree.parse(fd)
      return [entry.attrib for entry in xml.getroot().findall('entry')]
    except FileNotFoundError:
      return []

class TTYRec(object):
  """A wrapper for a binary file holding a DoomRL TTYRec."""
  def __init__(self, path):
    self.last_sgr = None
    self.last_pos = None
    self.last_s = int(time())
    self.delta = 0

    # If the file exists, read it to determine our current timestamp
    if exists(path):
      self.set_time_from(path)

    # Open the file for append
    self.fd = open(path, "ab")

  def __enter__(self):
    return self

  def __exit__(self, type, value, stack):
    self.fd.close()

  def set_time_from(self, path):
    with open(path, "rb") as fd:
      while True:
        header = fd.read(12)
        if not header:
          break
        (s, us, sz) = unpack("III", header)
        fd.read(sz)
        self.last_s = s

  def strip_pos(self, match):
    if match.group(0) == self.last_pos:
      return b''
    self.last_pos = match.group(0)
    return match.group(0)

  def strip_sgr(self, match):
    if match.group(0) == self.last_sgr:
      return b''
    self.last_sgr = match.group(0)
    return match.group(0)

  def write(self, s, us, sz, data):
    # strip out garbage commands
    trimmed = re.sub(b'\x1B\\[\\d+;\\d+H', self.strip_pos, data)
    trimmed = re.sub(b'\x1B\\[[\\d;]+m', self.strip_sgr, trimmed)
    trimmed = re.sub(b'\x1B\\[\\?7l', b'', trimmed)
    if trimmed:
      # if the frame survived, correct timestamp and write it
      if (s - self.delta) - self.last_s > 2:
        self.delta = s - self.last_s - 1
      s -= self.delta
      self.last_s = s
      self.fd.write(pack("III", s, us, sz))
      self.fd.write(data)


commands = {}
class CommandRegistration(type):
  def __new__(cls, clsname, bases, attrs):
    global commands
    newclass = super().__new__(cls, clsname, bases, attrs)
    name = clsname.replace('Command', '').lower()
    if name:
      commands[name] = newclass()
    return newclass

class Command(object, metaclass=CommandRegistration):
  nargs = 0
  def run(self, *args):
    return 'Not implemented yet.'

class RegisterCommand(Command):
  """register <name> <pass> -- create a new account

  Attempts to create (and log in to) a new user account. You can spectate and
  view the high score list as a guest, but in order to actually play you need to
  register.

  The username will be used as both your login username and your DoomRL username
  (and thus will appear on the high score list) and has certain restrictions as
  a result: 24 character maximum, alphanumeric ASCII only. The password can
  contain anything, including whitespace."""

  nargs = 2

  def install(self, home, name, password):
    """Install a personal copy of DoomRL to the given path."""
    # The player gets symlinks to the doomrl binary and wad files. They get
    # their own personal backup, mortem, screenshot, and recording directories,
    # and their own personal config files (so that they can be edited). We also
    # customize config.lua with the player's name.
    for file in ['core.wad', 'doomrl', 'doomrl.wad']:
      os.symlink(pjoin(DoomRL.doomrl, file), pjoin(home, file))
    for file in os.listdir(DoomRL.config):
      shutil.copy(pjoin(DoomRL.config, file), pjoin(home, file))
    for dir in ['backup', 'mortem', 'screenshot', 'saves', 'archive']:
      os.mkdir(pjoin(home, dir))
    with open(pjoin(home, 'passwd'), 'w') as passwd:
      passwd.write(password)
    with open(pjoin(home, 'config.lua'), 'a') as config:
      config.write('AlwaysName = "%s"\n' % name)


  def run(self, name, password):
    # Check name validity
    if not DoomRL.name_valid(name):
      return 'Invalid name.'

    # Check that password was specified
    if not password:
      return 'No password specified.'

    # Try to create user directory and die if we can't
    DoomRL.user = name
    home = DoomRL.player(name)
    try:
      os.mkdir(home)
    except OSError as e:
      return 'That name is unavailable.'

    # Fill in user directory
    log('Creating a new account: %s' % name)
    print('Creating user account.')
    try:
      self.install(home, name, password)
    except Exception as e:
      log('Error creating account %s: %s' % (name, e))
      print('Error creating user directory.')
      print('Report this to the server administrator.')
      try:
        shutil.rmtree(home)
      except OSError as e:
        log('Error cleaning up account %s: %s' % (name, e))
        print('Error cleaning up the half-created user directory! This username is unavailable until the admin fixes things.')
      finally:
        DoomRL.user = "guest"
        DoomRL.home = None
        return 'Unable to create user.'

    # Login
    return commands['login'].run(name, password)

class ConfigCommand(Command):
  """config <file> [reset] -- edit or reset configuration files

  As "config <file>", lets you edit one of your DoomRL configuration files.
  As "config <file> reset", lets you reset a file to defaults.
  As "config all reset", resets all files to defaults.

  Available files are:

    controls -- keyboard controls
    colours  -- game display colours
    user     -- user settings and general configuration

  Note that DoomRL has options not listed in any of these files; these options
  are overriden by the server and adding them yourself will have no effect.
  """

  nargs = 2

  def run(self, file, reset):
    if not DoomRL.home:
      return 'You must be logged in.'

    if reset and reset != 'reset':
      return 'Invalid second argument. See "help config".'

    files = frozenset(['controls', 'colours', 'user'])

    if reset and file == "all":
      print("Restoring default configuration files.")
      for file in os.listdir(DoomRL.config):
        shutil.copy(pjoin(DoomRL.config, file), DoomRL.homedir(file))
      with open(DoomRL.homedir('config.lua'), 'a') as config:
        config.write('AlwaysName = "%s"\n' % DoomRL.user)
      return

    if not file:
      print('Try "config <controls|colours|user>" or "help config".')
      return

    if file not in files:
      return 'Unknown file -- see "help config".'

    if reset:
      print('Restoring %s.lua to defaults.')
      shutil.copy(pjoin(DoomRL.config, file + '.lua'), DoomRL.home)
      return

    # Use Nano in secure mode to edit the file.
    subprocess.call(
      ['nano', '-R', DoomRL.homedir(file + '.lua')])

class LoginCommand(Command):
  """login <name> <pass> -- log in to an existing account.

  This is necessary in order to actually play games. To create a new account,
  use "register"."""

  nargs = 2

  def run(self, name, password):
    if DoomRL.home:
      return 'You are already logged in!'

    if not name or not password:
      return 'You must specify both a username and a password.'

    # Check password
    home = os.path.join(DoomRL.players, name)
    try:
      with open(os.path.join(home, 'passwd')) as f:
        passwd = f.read()
      if passwd == password:
        log('%s successfully logged in.' % name)
        DoomRL.home = home
        DoomRL.user = name
        return
    except IOError as e:
      pass

    log('Failed login attempt as %s' % name)
    DoomRL.home = None
    DoomRL.user = "guest"
    return 'Login failed.'

class HelpCommand(Command):
  """help [command] -- built in help for the DoomRL server.

  With no arguments, list all commands. With a command specified, shows detailed
  help for that command."""

  nargs = 1

  def run(self, cmd):
    from inspect import getdoc

    if not cmd:
      for cmd in commands:
        print(getdoc(commands[cmd]).split('\n')[0])
      return

    if not cmd in commands:
      print('No such command. Try "help" for a list of all commands.')
    else:
      print(getdoc(commands[cmd]))

class PlayCommand(Command):
  """play <name> -- start or continue a game of DoomRL.

  Without arguments, list your saved games. With a name, start or resume a game
  with that name.

  The game will automatically be recorded and made available for spectating.

  If you save and quit, the savegame will be automatically archived under the
  name you chose. You can resume it later by providing the same name, or start
  a new game in parallel by providing a different one. This allows you to (for
  example) have a long running Angel of 666 game in one save, while still taking
  breaks for shorter standard games.
  """

  nargs = 1

  def setup(self, name):
    # If the player has a game in progress, restore their ttyrec and save.
    if exists(self.recfile + '.' + name):
      os.rename(self.recfile + '.' + name, self.recfile)
      print('Recording of current game restored.')
    if exists(DoomRL.homedir('saves', name)):
      os.rename(DoomRL.homedir('saves', name), DoomRL.homedir('save'))

    # Get their pre-game high scores so we can check for new ones afterwards.
    scores_before = DoomRL.scores(DoomRL.user)
    try:
      mortem_before = DoomRL.mortems(DoomRL.user)[-1]
    except IndexError:
      mortem_before = None

    return (scores_before,mortem_before)

  def run_doomrl(self):
    # Invoke DoomRL inside ttyrec. Rather than letting ttyrec write directly
    # to disk, we hand it an FD and then process the contents of that fd.
    (rpipe,wpipe) = os.pipe()
    ttyrec = subprocess.Popen(
      ['ttyrec', '-e', './doomrl', '-a', '/dev/fd/%d' % wpipe],
      pass_fds=(0,1,2,wpipe),
      cwd=DoomRL.home)
    os.close(wpipe)

    # Now we read from the pipe and process the output until it's closed,
    # stripping out garbage frames and writing the rest to disk.
    with TTYRec(self.recfile) as rec:
      while True:
        header = os.read(rpipe, 12)
        if not header:
          break
        (s, us, sz) = unpack("III", header)
        data = os.read(rpipe, sz)
        rec.write(s, us, sz, data)

    os.close(rpipe)

  def run(self, name):
    if not DoomRL.home:
      return 'You must log in first.'

    if not name:
      # List games in progress
      saves = os.listdir(DoomRL.homedir('saves'))
      if not saves:
        print('You have no games in progress.')
      else:
        print('Games in progress:')
        for save in saves:
          print('\t', save)
        print('Type "play <name>" to resume one.')
      return

    # We can be a bit looser about names here, but for simplicity's sake we
    # just reuse the name validation code we use for player names.
    if not DoomRL.name_valid(name):
      return 'Invalid save name.'

    # Check that they aren't already playing *right now*.
    self.recfile = DoomRL.game(DoomRL.user)
    if exists(self.recfile):
      return 'You are already playing in another window! Quit that game first.'

    (scores,mortem) = self.setup(name)
    try:
      self.run_doomrl()
    except Exception as e:
      # If something went wrong while playing DoomRL, the terminal is probably
      # completely hosed and there may still be processes running in the
      # background. Nothing to do here but die and hope the SIGHUP gets them.
      subprocess.call(['reset'])
      print('Fatal error running DoomRL:', e)
      sys.exit(1)
    finally:
      self.shutdown(name, scores, mortem)

  def shutdown(self, name, scores_before, mortem_before):
    # If the game is still in progress, save the ttyrec file.
    if exists(DoomRL.player(DoomRL.user, 'save')):
      os.rename(self.recfile, self.recfile + '.' + name)
      os.rename(DoomRL.homedir('save'), DoomRL.homedir('saves', name))
    else:
      # Otherwise, there *should* be a new high score entry and a new mortem.
      # Unless they simply didn't start a game in the first place.
      try:
        mortem = DoomRL.mortems(DoomRL.user)[-1]
      except IndexError:
        mortem = None

      if mortem == mortem_before:
        # No new postmortem created and no save file means no game played.
        os.remove(DoomRL.game(DoomRL.user))
        return

      # Write the new score entry to the player's scores file.
      scores_after = DoomRL.scores(DoomRL.user)
      n = len(scores_after)
      for (i,score) in enumerate(scores_after):
        if i >= len(scores_before) or scores_before[i] != score:
          with open(DoomRL.homedir('archive', 'scores'), "a") as fd:
            score['n'] = n
            fd.write(str(score) + '\n')
            break

      # Save the ttyrec and mortem files to the player archive directory.
      os.rename(DoomRL.game(DoomRL.user),
                DoomRL.homedir('archive', '%d.ttyrec' % n))
      shutil.copy(DoomRL.homedir('mortem', mortem),
                  DoomRL.homedir('archive', '%d.mortem' % n))

class WatchCommand(Command):
  """watch <player> -- watch an in-progress game of DoomRL.

  With no arguments, lists all currently active games. With the name of a
  player, spectates that player's game.

  The replay has an initial 'catch-up' phase where it replays the game so far
  at 64x normal speed. During this period the normal replay controls (see
  "help replay") will work. At any point you can exit spectator mode with ctrl-C.

  If the person you are spectating exits, the screen will go black and won't
  automatically return to the prompt -- this is a limitation of the underlying
  software used for replays. Once this happens, press ctrl-C to exit.
  """

  nargs = 1

  def run(self, player):
    if not player:
      # list active games
      print('SECONDS PLAYER')
      for player in DoomRL.all_players():
        if exists(DoomRL.game(player)):
          subprocess.call(['ttytime', player], cwd=DoomRL.games)
      return

    if not exists(DoomRL.game(player)):
      return 'No game in progress under that name.'

    try:
      # First we 'catch up' by playing the game so far at 16x speed.
      subprocess.call(
        ['ttyplay', '-s', '16', player],
        cwd=DoomRL.games)
      # Then we peek at what remains.
      subprocess.call(
        ['ttyplay', '-p', player],
        cwd=DoomRL.games)
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class ReplayCommand(Command):
  """replay <player> <number> -- replay a recorded game

  With no arguments, lists all players with recorded games. With a player name,
  lists the recorded games for that player. With a name and a replay number,
  replays the given name. The replay number can be found out from the list of
  that player's replays.

  You can also use "latest" to view the latest replay for that player.

  If you know the exact timestamp of the replay (also given in the list), you
  can use that in place of the replay number.

  Replay controls:
    f or +: go faster
    s or -: go slower
    1: reset speed
    ctrl-c: exit replay
    anything else: skip to the next player input (useful for long idle periods)
  """

  nargs = 2

  def replays(self, player):
    return sorted(os.listdir(DoomRL.player(player, 'recording')))

  def list_players(self):
    """List all players with recordings, and how many."""
    print(' NUM  PLAYER')
    for player in DoomRL.all_players():
      replays = len(self.replays(player))
      if replays > 0:
        print('%4d  %s' % (replays, player))

  def list_replays(self, player):
    """List all recordings for this player."""
    print('  ID  TIME')
    for (index, replay) in enumerate(self.replays(player)):
      print('%4d  %s' % (index, replay[1:20]))

  def run(self, player, id):
    if not player:
      return self.list_players()
    elif not DoomRL.player_exists(player):
      return 'No such player: %s' % player
    elif not id:
      return self.list_replays(player)

    # Replay the named recording.
    replays = self.replays(player)
    if id == "latest":
      recname = replays[-1]
    else:
      try:
        recname = replays[int(id)]
      except:
        recname = '[%s] %s.ttyrec' % (id, player)

    if not exists(DoomRL.player(player, 'recording', recname)):
      return 'No such replay found.'

    try:
      subprocess.call(
        ['ttyplay', recname],
        cwd=DoomRL.player(player, 'recording'))
    except KeyboardInterrupt:
      pass
    finally:
      # ttyplay may leave the terminal messed up. This fixes it.
      subprocess.call(['reset'])

class ScoresCommand(Command):
  """scores [player] -- show high score list

  With no arguments, show the entire scoreboard. With a given player, show only
  scores for that player. Use the arrow keys or pageup/down to scroll, and q to
  quit.

  Note that due to restrictions on how DoomRL stores the high score list, the
  in-game high scores will always only show your own."""

  nargs = 1

  def run(self, player):
    if not player:
      scores = []
      for player in DoomRL.all_players():
        scores += DoomRL.scores(player)
    else:
      scores = DoomRL.scores(player)

    scores.sort(reverse=True, key=lambda s: int(s['score']))

    difficulties = ['', 'E', 'M', 'H', 'U', 'N!']
    classes = { 'marine': 'M', 'scout': 'S', 'technician': 'T' }
    less = subprocess.Popen(
      ['less'],
      universal_newlines=True,
      env={'LESSSECURE': '1', 'TERM': os.getenv('TERM')},
      stdin=subprocess.PIPE)
    for score in scores:
      less.stdin.write(' %2s %7s %-24s %sL:%-2s %-34s L%-2s %s\n' % (
        difficulties[int(score['difficulty'])],
        score['score'],
        score['name'],
        classes[score['klass']],
        score['level'],
        score['killed'],
        score['depth'],
        score.get('challenge', '')))
    less.stdin.close()
    less.wait()

class MortemCommand(Command):
  """mortem <player> <number> -- view a postmortem

  With no arguments, lists all players with postmortems. With a player name,
  lists the available postmortems. With a number or date, view that postmortem.

  You can also use "latest" to view the latest postmortem for that player.

  The viewer used is less(1). Use pageup/down or the arrow keys to scroll, q to
  quit. You can press h or H at any time for help.
  """

  nargs = 2

  def list_players(self):
    """List all players with mortems, and how many."""
    print(' NUM  PLAYER')
    for player in DoomRL.all_players():
      mortems = len(DoomRL.mortems(player))
      if mortems > 0:
        print('%4d  %s' % (mortems, player))

  def list_mortems(self, player):
    """List all mortems for this player."""
    print('  ID  TIME')
    for (index, mortem) in enumerate(DoomRL.mortems(player)):
      print('%4d  %s' % (index, mortem[1:20]))

  def run(self, player, id):
    if not player:
      return self.list_players()
    elif not id:
      return self.list_mortems(player)

    mortems = DoomRL.mortems(player)
    if id == "latest":
      mortem = mortems[-1]
    else:
      try:
        mortem = mortems[int(id)]
      except:
        mortem = '[%s] %s.txt' % (id, player)

    if not exists(DoomRL.player(player, 'mortem', mortem)):
      return 'No such mortem found.'

    try:
      subprocess.call(
        ['less', '-d', '-M', mortem],
        cwd=DoomRL.player(player, 'mortem'),
        env={
          'LESSSECURE': '1',
          'TERM': os.getenv('TERM')
        })
    except KeyboardInterrupt:
      pass
    finally:
      pass
      #subprocess.call(['reset'])


def sighup(sig, frame):
  """Signal handler for SIGHUP, which is raised when the user disconnects suddenly."""
  # If we got interrupted halfway through creating the player's profile, then
  # DoomRL.user will be set and DoomRL.home won't be (a normal login sets them
  # in the opposite order, so if we get interrupted halfway through login it's
  # safe). In that case we should remove the half-constructed player profile
  # so that the name can be re-used.
  if DoomRL.user != 'guest' and not DoomRL.home:
    shutil.rmtree(DoomRL.player(DoomRL.user), ignore_errors=True)
    return

  if DoomRL.home and DoomRL.user:
    # If we got interrupted while the player was actually in DoomRL, there's a
    # ttyrec file. It's possible they did something super cool before everything
    # went sideways, so we should save it.
    try:
      when = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')
      what = '[%s] %s.ttyrec' % (when, DoomRL.user)
      os.rename(
        DoomRL.game(DoomRL.user),
        DoomRL.homedir('recording', what))
    except FileNotFoundError:
      pass


def argsplit(string, max=2):
  args = string.split(maxsplit=max-1)
  while len(args) < max:
    args.append('')
  return args

def main():
  from signal import signal,SIGHUP
  signal(SIGHUP, sighup)

  syslog.openlog('doomrl-server', facility=syslog.LOG_DAEMON)

  print("""
=================     ===============     ===============   ========  ========
\\\\ . . . . . . .\\\\   //. . . . . . .\\\\   //. . . . . . .\\\\  \\\\. . .\\\\// . . //
||. . ._____. . .|| ||. . ._____. . .|| ||. . ._____. . .|| || . . .\/ . . .||
|| . .||   ||. . || || . .||   ||. . || || . .||   ||. . || ||. . . . . . . ||
||. . ||   || . .|| ||. . ||   || . .|| ||. . ||   || . .|| || . | . . . . .||
|| . .||   ||. _-|| ||-_ .||   ||. . || || . .||   ||. _-|| ||-_.|\ . . . . ||
||. . ||   ||-'  || ||  `-||   || . .|| ||. . ||   ||-'  || ||  `|\_ . .|. .||
|| . _||   ||    || ||    ||   ||_ . || || . _||   ||    || ||   |\ `-_/| . ||
||_-' ||  .|/    || ||    \|.  || `-_|| ||_-' ||  .|/    || ||   | \  / |-_.||
||    ||_-'      || ||      `-_||    || ||    ||_-'      || ||   | \  / |  `||
||    `'         || ||         `'    || ||    `'         || ||   | \  / |   ||
||            .===' `===.         .==='.`===.         .===' /==. |  \/  |   ||
||         .=='   \_|-_ `===. .==='   _|_   `===. .===' _-|/   `==  \/  |   ||
||      .=='    _-'    `-_  `='    _-'   `-_    `='  _-'   `-_  /|  \/  |   ||
||   .=='    _-'          `-__\._-'         `-_./__-'         `' |. /|  |   ||
||.=='    _-'                                                     `' |  /==.||
=='    _-'               DoomRL by Kornel Kisielewicz                 \/   `==
\   _-'                   DoomRL Server by Ben Kelly                   `-_   /
 `''                                                                      ``'

Type 'help' for a list of commands.""")

  (cols, rows) = shutil.get_terminal_size()
  if int(rows) < 25 or int(cols) < 80:
    print("Warning: your terminal size (%sx%s) is smaller than the 80x25"
          " needed by DoomRL. The 'play', 'replay', and 'watch' commands"
          " may not work correctly." % (cols, rows))

  while True:
    try:
      [cmd, args] = argsplit(input('\n%s> ' % DoomRL.user).strip())
      if cmd in commands:
        result = commands[cmd].run(*argsplit(args, max=commands[cmd].nargs))
        if result:
          print('Error: %s' % result)
      elif cmd == 'quit':
        break
      elif not cmd:
        pass
      else:
        print('Error: Unrecognized command. Try "help".')
    except EOFError as e:
      break
    except KeyboardInterrupt:
      pass
    except Exception as e:
      log('Unhandled exception in mainloop: %s' % str(e))
      print('Error in mainloop: %s' % str(e))

  if DoomRL.home:
    log('User %s logged out.' % DoomRL.user)
  print('Goodbye!')

if __name__ == '__main__':
  main()
